# version 450
#define MATH_PI 3.1415926535897932384626433832795


// layout(binding = 0) uniform samplerCube envMap;

//set up descriptor
layout(set=0, binding = 0) uniform samplerCube envMap;
layout(set = 0, binding = 1, rgba32f) writeonly uniform image2DArray dst;

layout(push_constant) uniform PerFrameData{
    uint face;
    float roughness;

    uint width;
    uint height;

    uint sampleCount;
    uint distribution;
}perFrameData;

const int cLambertian = 0;
const int cGGX = 1;



struct MicrofacetDistributionSample{
    float pdf;
    float cosTheta;
    float sinTheta;
    float phi;
};


float random(vec2 co)
{
	float a = 12.9898;
	float b = 78.233;
	float c = 43758.5453;
	float dt= dot(co.xy ,vec2(a,b));
	float sn= mod(dt,3.14);
	return fract(sin(sn) * c);
}

//hammersley2d  pseudo-random number
vec2 hammersley2d(uint i, uint N){
    uint bits = (i<<16u)|(i>>16u);
    bits = ( (bits & 0x55555555u)<<1u ) | ( (bits & 0xAAAAAAAAu)>>1u );
    bits = ( (bits & 0x33333333u)<<2u ) | ( (bits & 0xCCCCCCCCu)>>2u );
    bits = ( (bits & 0x0F0F0F0Fu)<<4u ) | ( (bits & 0xF0F0F0F0u)>>4u );
    bits = ( (bits & 0x00FF00FFu)<<8u ) | ( (bits & 0xFF00FF00u)>>8u );
    float radicalInverse = float(bits) * 2.3283064365386963e-10;
    return vec2(float(i)/float(N) , radicalInverse);
}

// GGX D term
float D_GGX(float NdotH, float roughness){
    float alpha = roughness*roughness;
    float alpha2 = alpha * alpha;
    // float denom = alpha*alpha*NdotH*NdotH - NdotH*NdotH + 1;
    float denom = NdotH * NdotH * (alpha2 - 1.0 ) + 1.0;
    return alpha2 / (MATH_PI * denom * denom);
    //得到的是分布密度值distribution value，表示某个法向量方向上维表面的密度
}

mat3 generate_TB_normal(vec3 normal){
    vec3 bitangent = vec3(0.0, 1.0, 0.0);
    float NdotUp = dot(normal, vec3(0.0, 1.0, 0.0));
    float epsilon = 0.0000001;
    if(  1.0 - abs(NdotUp) <=  epsilon){
        bitangent = (NdotUp>0.0) ? vec3(0.0, 0.0, 1.0) : vec3(0.0, 0.0, -1.0);
    }

    vec3 tangent = normalize(cross(bitangent, normal));
    bitangent = cross(normal, tangent);

    return mat3(tangent, bitangent, normal);
}




///////////////////////////////////////////////////////////////////////////
//irradiance map
MicrofacetDistributionSample Lambertian(vec2 xi, float roughness){
    //cosine-weighted hemisphere sampling

    MicrofacetDistributionSample lambertian;

    lambertian.cosTheta = sqrt(1.0 - xi.y);
    lambertian.sinTheta = sqrt(xi.y);
    lambertian.phi = 2.0 * MATH_PI * xi.x;

    lambertian.pdf = lambertian.cosTheta / MATH_PI;
    return lambertian;
}

//GGX
//在为IBL滤波做按GGX的NDF采样H并给出对L的pdf

MicrofacetDistributionSample GGX(vec2 xi, float roughness){

    MicrofacetDistributionSample ggx;
    float alpha = roughness* roughness;  //isotropic
    ggx.cosTheta = clamp( sqrt(  (1.0-xi.y) / (1.0+(alpha*alpha-1.0)*xi.y)  )  , 0.0, 1.0  );
    ggx.sinTheta = sqrt( 1.0 - ggx.cosTheta * ggx.cosTheta);
    ggx.phi = 2.0 * MATH_PI * xi.x;

    ggx.pdf = D_GGX(ggx.cosTheta, roughness);
    ggx.pdf /= 4.0;

    //将distribution function到probability density function的转换，要考虑秋坐标系的几何
    //cosTheta = N dot H.. theta是与法线N的夹角。
    // Typically you'd have the following:
    //   float pdf = D_GGX(NoH, roughness) * NoH / (4.0 * VoH);
    // but since V = N => VoH == NoH

    return ggx;
}


///////////////////////////////////////////////////////////////////////////

//importance sample direction with pdf in the .w component
vec4 getImportanceSample(uint sampleIndex, vec3 N, float roughness){
    vec2 xi = hammersley2d(sampleIndex, perFrameData.sampleCount);

    MicrofacetDistributionSample importanceSample;

    if(perFrameData.distribution == cLambertian){
        importanceSample = Lambertian(xi, roughness);
    }
    else if(perFrameData.distribution == cGGX){
        importanceSample = GGX(xi, roughness);
    }

    //transform the hemisphere sample to the normal coordinate frame. hemisphere->normal direction
    vec3 localSpaceDirection = normalize(vec3(
        importanceSample.sinTheta * cos(importanceSample.phi),
        importanceSample.sinTheta * sin(importanceSample.phi),
        importanceSample.cosTheta    ));
    
    mat3 TB_normals = generate_TB_normal(N);
    vec3 worldSpaceDirection = TB_normals * localSpaceDirection;
    return vec4(worldSpaceDirection, importanceSample.pdf);
}


//用于prefiltered envmap 生成specular IBL
float computeLod(float pdf){
    float width = float(perFrameData.width);
    float height = float(perFrameData.height);
    float sampleCount = float(perFrameData.sampleCount);

    // float saTexel = 4.0 * MATH_PI/(6.0* width*height);
    // float saSample = 1.0/(max(1.0, float(sampleCount)) * max(pdf, 1e-6));
    // float lod = max(0.0, 0.5 * log2(saSample / saTexel));
    float lod = 0.5 * log2(  6.0*width*height  /  (sampleCount*pdf)  );

    return lod;
}

//return H
vec3 importanceSample_GGX(vec2 Xi, float roughness, vec3 normal) 
{
	// Maps a 2D point to a hemisphere with spread based on roughness
	float alpha = roughness * roughness;
	float phi = 2.0 * MATH_PI * Xi.x + random(normal.xz) * 0.1;
	float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (alpha*alpha - 1.0) * Xi.y));
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
	vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);

	// Tangent space
	vec3 up = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
	vec3 tangentX = normalize(cross(up, normal));
	vec3 tangentY = normalize(cross(normal, tangentX));

	// Convert to world Space
	return normalize(tangentX * H.x + tangentY * H.y + normal * H.z);
}


///////////////////////////////////////////////////////////////////////////

// here for ggx , use the example from sacha willems example  https://github.com/SaschaWillems/Vulkan/blob/master/shaders/glsl/pbrtexture/prefilterenvmap.frag
// for lambertian, continue use vulkan cookbook
// need organize
vec3 filterColor(vec3 N){
    vec3 V = N;                
    vec3 color = vec3(0.0f);
    float weights = 0.0f;

    float envMapDim = float(textureSize(envMap,0).x); //original per face size
    
    for(uint i = 0; i < perFrameData.sampleCount; i++){
        vec4 importanceSample = getImportanceSample(i, N , perFrameData.roughness);

        vec2 Xi = hammersley2d(i, perFrameData.sampleCount);
        vec3 H = importanceSample_GGX(Xi, perFrameData.roughness, N);
        vec3 L = 2.0 * dot(V, H) * H - V;
        // vec3 L = normalize(reflect(-V, H)); 
        float NdotL = clamp(dot(N, L), 0.0, 1.0);

        vec3 H_forIrrad = vec3(importanceSample.xyz);
        float pdf_forIrrad = importanceSample.w;
        float lod_forIrrad = computeLod(pdf_forIrrad);

        if (perFrameData.distribution == cGGX){
            if(NdotL > 0.0){
                float NdotH = clamp(dot(N, H), 0.0, 1.0);
                float VdotH = clamp(dot(V, H), 0.0, 1.0);

                // Probability Distribution Function
                float pdf = D_GGX(NdotH, perFrameData.roughness) * NdotH / (4.0 * VdotH) + 0.0001;
                // Slid angle of current smple
                float omegaS = 1.0 / (float(perFrameData.sampleCount) * pdf);
                // Solid angle of 1 pixel across all cube faces
                float omegaP = 4.0 * MATH_PI / (6.0 * envMapDim * envMapDim);
                // Biased (+1.0) mip level for better result
                float mipLevel = perFrameData.roughness == 0.0 ? 0.0 : max(0.5 * log2(omegaS / omegaP) + 1.0, 0.0f);
                color += textureLod(envMap, L, mipLevel).rgb * NdotL;
                weights += NdotL;
            }
        }
        else if(perFrameData.distribution == cLambertian){
            vec3 lambertian = textureLod(envMap, H_forIrrad, lod_forIrrad).xyz;  //vec4 textureLod(samplerCube sampler, vec3 coord, float lod)
            // vec3 lambertian = textureLod(envMap, normalize(N), 0.0f).xyz; 
            color += lambertian;
        }
    }

    color /= (weights!=0.0f) ? weights : float(perFrameData.sampleCount);
    return color.rgb;
}

vec3 uvToXYZ(uint face, vec2 uv)
{
 if (face == 0) return vec3( 1.0,  -uv.y, -uv.x); // +X
  if (face == 1) return vec3(-1.0,  -uv.y,  uv.x); // -X  
  if (face == 2) return vec3( uv.x,   1.0,  uv.y); // +Y
  if (face == 3) return vec3( uv.x,  -1.0, -uv.y); // -Y
  if (face == 4) return vec3( uv.x,  -uv.y,  1.0); // +Z
  if (face == 5) return vec3(-uv.x,  -uv.y, -1.0); // -Z
}



layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;


void main(){
    ivec3 coords = ivec3(gl_GlobalInvocationID);
    
    if (coords.x >= perFrameData.width || coords.y >= perFrameData.height) {
        return;
    }
    
    // Convert pixel coordinates to UV coordinates [-1, 1]
    vec2 uv = (vec2(coords.xy) + 0.5) / vec2(perFrameData.width, perFrameData.height) * 2.0 - 1.0;
    
    // Get the cube direction for this face and UV coordinate
    vec3 N = normalize(uvToXYZ(perFrameData.face, uv));
    
    // Filter the color using importance sampling
    vec3 color = filterColor(N);
    
    // Write to the output cubemap
    imageStore(dst, ivec3(coords.xy, int(perFrameData.face)), vec4(color, 1.0));
}




// void main(){
//     ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
//     // 由 C++ 计算 gx/gy 做边界裁剪也行；保险起见再判一次
//     // if (pix.x >= faceSize || pix.y >= faceSize) return; // 如需，额外传 faceSize

//     // 先占位：直接采样（把你的积分逻辑贴进来即可）
//     // 真实实现里按 distribution + roughness 做 GGX/IBL 重要性采样 + textureLod
//     vec2 uv = (vec2(pix)+0.5); // 只是占位别忘了换成你自己的方向映射
//     vec3 dir = vec3(0,0,1);    // TODO: 用你的 face/uv->dir
//     vec3 c = textureLod(uEnv, dir, 0.0).rgb;

//     imageStore(uDst, ivec3(pix, int(pc.face)), vec4(c,1.0));
// }